# -*- coding: utf-8 -*-
"""xGModel

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zGpbBKK2-D8r16PLyftVvPF4J-0752RY
"""



!pip install mplsoccer

from google.colab import files


uploaded = files.upload()

import numpy as np
import pandas as pd
import ast
import math
import matplotlib.pyplot as plt

shot = pd.read_csv('shot_train.csv')  # read data from file

shot_test = pd.read_csv('shot_test.csv')

shot

shot_test

shot['under_pressure'] = shot['under_pressure'].fillna(False)
shot['shot_one_on_one'] = shot['shot_one_on_one'].fillna(False)
shot['shot_aerial_won'] = shot['shot_aerial_won'].fillna(False)
shot_test['under_pressure'] = shot_test['under_pressure'].fillna(False)
shot_test['shot_one_on_one'] = shot_test['shot_one_on_one'].fillna(False)
shot_test['shot_aerial_won'] = shot_test['shot_aerial_won'].fillna(False)
shot['pref_foot_shot'] = shot['pref_foot'] == shot['shot_body_part']
shot_test['pref_foot_shot'] = shot_test['pref_foot'] == shot_test['shot_body_part']

#added criteria for revisions
shot['shot_first_time'] = shot['shot_first_time'].fillna(False)
shot_test['shot_first_time'] = shot_test['shot_first_time'].fillna(False)


# Create a new dataframe with additional columns
shot_data = (
    shot
        .assign(
            is_goal=lambda x: np.where(x['shot_outcome'] == "Goal", 1, 0),
            # Use the ast.literal_eval function to convert location strings into lists
            # NOTE: This ast.literal_eval function will come in very handy if you
            #       choose to work with the freeze frame data in Assignment #2!
            loc_x=lambda x: [ast.literal_eval(y)[0] for y in x['location']],
            loc_y=lambda x: [ast.literal_eval(y)[1] for y in x['location']],
            distance=lambda x: np.sqrt((x['loc_x'] - 120)**2 + (x['loc_y'] - 40)**2),
            angle=lambda x: [math.atan(y) for y in (x['loc_y'] - 40) / (x['loc_x'] - 120)],
            # Calculate more useful transformations of angle and distance
            sqrt_distance=lambda x: np.sqrt(x['distance']),
            cos_angle=lambda x: [math.cos(y) for y in x['angle']]
        )
)


shot_testing_data = (
    shot
        .assign(
            is_goal=lambda x: np.where(x['shot_outcome'] == "Goal", 1, 0),
            # Use the ast.literal_eval function to convert location strings into lists
            # NOTE: This ast.literal_eval function will come in very handy if you
            #       choose to work with the freeze frame data in Assignment #2!
            loc_x=lambda x: [ast.literal_eval(y)[0] for y in x['location']],
            loc_y=lambda x: [ast.literal_eval(y)[1] for y in x['location']],
            distance=lambda x: np.sqrt((x['loc_x'] - 120)**2 + (x['loc_y'] - 40)**2),
            angle=lambda x: [math.atan(y) for y in (x['loc_y'] - 40) / (x['loc_x'] - 120)],
            # Calculate more useful transformations of angle and distance
            sqrt_distance=lambda x: np.sqrt(x['distance']),
            cos_angle=lambda x: [math.cos(y) for y in x['angle']]
        )
)
# Shuffle the rows and separate training set from test set
shot_shuffled = shot_data.sample(frac=1, random_state=42)
shot_train = shot_shuffled[:5200]
shot_testing = shot_shuffled[5201:]
shot_data = shot_data[shot_data['distance'].notna()]



# This block of code calculates the average for all numeric columns within each bucket of distance
# rounded to the nearest two meters, most importantly the average of is_goal within each bucket.
plot_data = (
    shot_data
        # Create rounded_distance, which is distance rounded to the nearest multiple of 2 meters
        .assign(rounded_distance=lambda x: round(x['distance'] / 2) * 2)
        .groupby('rounded_distance')
        .mean(numeric_only=True)
)

plot_data

# Perform exploratory data analysis to examine relationship between distance and goal probability
plt.scatter(plot_data['distance'], plot_data['is_goal'])

import statsmodels.formula.api as smf
import statsmodels.api as sm


# Fit a logistic regression model for goal probability using distance and angle
model = (
    smf.glm(
        formula="is_goal ~ sqrt_distance + cos_angle",
        data=shot_train,
        family=sm.families.Binomial()
    )
        .fit()
)

# Make predictions in the test set and evaluate the log probability of each outcome
shot_testing = (
    shot_testing
        .assign(
            pred=model.predict(exog=shot_testing),
            # Find the predicted probability corresponding to the actual outcome
            prob=lambda x: np.where(x['is_goal'], x['pred'], 1 - x['pred']),
            log_prob=lambda x: np.log(x['prob'])
        )
)

# Calculate the average log probability in the test set
print(np.mean(shot_testing['log_prob']))

# Fit a logistic regression model for goal probability using the added categories
model = (
    smf.glm(
        formula="is_goal ~ sqrt_distance + cos_angle + sqrt_distance * cos_angle  + shot_one_on_one + shot_aerial_won + under_pressure + pref_foot_shot",
        data=shot_train,
        family=sm.families.Binomial()
    )
        .fit()
)

# Make predictions in the test set and evaluate the log probability of each outcome
shot_testing = (
    shot_testing
        .assign(
            pred=model.predict(exog=shot_testing),
            # Find the predicted probability corresponding to the actual outcome
            prob=lambda x: np.where(x['is_goal'], x['pred'], 1 - x['pred']),
            log_prob=lambda x: np.log(x['prob'])
        )
)

# Calculate the average log probability in the test set
print(np.mean(shot_testing['log_prob']))
shot_testing

print(np.mean(shot_testing['log_prob']))



standard_error =  (np.std(shot_testing['log_prob']))/(np.sqrt(shot_test.shape[0]))
mean = np.mean(shot_testing['log_prob'])
print("95% Confidence Interval: " + str((mean-(2*standard_error), mean+(2*standard_error))))
shot_test= (shot_test.assign(pred=model.predict(exog=shot_testing_data),))
standard_error

shot_test.columns

!pip install mplsoccer

import mplsoccer as mpl

# this is the same visualization from pyday, just to give a base visualization of xG
# Draw the soccer pitch
pitch = mpl.Pitch()
fig, ax = pitch.draw()
# Plot the shots from the test set
points = pitch.scatter(
    x=shot_testing['loc_x'],
    y=shot_testing['loc_y'],
    s=5,
    c=shot_testing['pred'],    # color according to xG
    alpha=0.5,
    cmap='jet',
    ax=ax
)
plt.colorbar(points)        # add a legend for interpreting the color

import matplotlib.pyplot as plt
import mplsoccer as mpl

# Filter the shots where 'shot_body_part' is the same as 'pref_foot'
filtered_shots = shot_testing[shot_testing['shot_body_part'] == shot_testing['pref_foot']]

# Draw the soccer pitch
pitch = mpl.Pitch()
fig, ax = pitch.draw()

# Plot the shots from the filtered DataFrame
points = pitch.scatter(
    x=filtered_shots['loc_x'],
    y=filtered_shots['loc_y'],
    s=5,
    c=filtered_shots['pred'],  # color according to xG
    alpha=0.5,
    cmap='jet',
    ax=ax
)

plt.colorbar(points)
plt.show()



shot_test = shot_test.rename(columns={'pred': 'prob_goal'})
shot_test

# Create a list of columns to keep
columns_to_keep = ['id', 'prob_goal']

# Use the drop method to remove all other columns
shot_test = shot_test[columns_to_keep]
shot_test

shot_test.to_csv('prob_goal.csv')





